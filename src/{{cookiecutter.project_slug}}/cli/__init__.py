"""
Command-Line Interface (CLI) Package for {{cookiecutter.project_slug}}.

This module serves as the primary gateway for command-line interactions with the odor plume 
navigation system, providing comprehensive Click-based commands with Hydra configuration 
integration. The CLI package exposes entry points for simulation execution, configuration 
management, visualization export, and batch processing workflows.

Key Features:
- Hydra-based configuration management with hierarchical composition
- Click framework integration for sophisticated command structure  
- Parameter override capabilities via command-line flags
- <2s command initialization time per Section 2.2.9.3 performance criteria
- Support for both direct module invocation and package-level CLI access
- Comprehensive help generation and usage documentation

Entry Points:
- `python -m {{cookiecutter.project_slug}}.cli.main` - Direct module invocation
- `{{cookiecutter.project_slug}} command` - Package-level CLI access (when installed)
- `from {{cookiecutter.project_slug}}.cli import main` - Programmatic access

Configuration Integration:
The CLI system integrates seamlessly with Hydra's configuration management, supporting:
- Hierarchical configuration composition (base.yaml → config.yaml → local overrides)
- Environment variable interpolation and dynamic parameter injection
- Multi-run parameter sweeps via --multirun flag for batch experiment execution
- Local configuration overrides from conf/local/ directory

Command Structure:
- run: Execute simulation with comprehensive parameter override support
- config: Configuration management (validate, export, debug commands)
- visualize: Generate publication-quality visualizations from simulation results
- Additional commands available through extensible Click command registration

Performance Requirements:
- Command initialization: <2 seconds per Section 2.2.9.3
- Configuration loading: <1 second for complex Hydra configurations
- CLI response time: Interactive feedback with real-time parameter validation
- Memory overhead: <100MB CLI overhead per requirements

Author: Generated by Blitzy Template Engine
Version: 2.0.0
"""

import sys
import time
import logging
from typing import Any, Dict, List, Optional, Callable, Union

# Import main CLI components for re-export and unified namespace access
try:
    from .main import (
        main,
        cli,
        run,
        config,
        visualize,
        validate_configuration,
        initialize_system,
        cleanup_system,
        get_cli_config,
        set_cli_config,
        CLIError,
        handle_cli_exception
    )
    
    # Mark successful CLI component imports for diagnostics
    _CLI_COMPONENTS_AVAILABLE = True
    _CLI_IMPORT_ERRORS = []
    
except ImportError as e:
    # Graceful handling of missing dependencies during development or partial installations
    _CLI_COMPONENTS_AVAILABLE = False
    _CLI_IMPORT_ERRORS = [str(e)]
    
    # Provide stub implementations to prevent import failures
    def main(*args, **kwargs) -> None:
        """Stub implementation when CLI components are unavailable."""
        raise RuntimeError(f"CLI components not available: {_CLI_IMPORT_ERRORS}")
    
    def cli(*args, **kwargs) -> None:
        """Stub implementation when CLI components are unavailable."""
        raise RuntimeError(f"CLI components not available: {_CLI_IMPORT_ERRORS}")
    
    # Define other stub functions as needed
    CLIError = Exception


# Package metadata and version information
__version__ = "2.0.0"
__author__ = "Generated by Blitzy Template Engine"

# CLI component availability and status information
__cli_available__ = _CLI_COMPONENTS_AVAILABLE
__import_errors__ = _CLI_IMPORT_ERRORS


def get_cli_status() -> Dict[str, Any]:
    """
    Retrieve comprehensive CLI package status and diagnostic information.
    
    Returns:
        Dict containing CLI availability, version, import status, and performance metrics
        
    Example:
        >>> from {{cookiecutter.project_slug}}.cli import get_cli_status
        >>> status = get_cli_status()
        >>> print(f"CLI Available: {status['available']}")
        CLI Available: True
    """
    return {
        'available': _CLI_COMPONENTS_AVAILABLE,
        'version': __version__,
        'import_errors': _CLI_IMPORT_ERRORS,
        'components': {
            'main': 'main' in globals(),
            'cli': 'cli' in globals(),
            'commands': ['run', 'config', 'visualize'] if _CLI_COMPONENTS_AVAILABLE else [],
        },
        'python_version': sys.version_info[:3],
        'performance': {
            'initialization_target': '<2s',
            'memory_limit': '<100MB overhead'
        }
    }


def verify_cli_performance() -> Dict[str, Union[bool, float, str]]:
    """
    Verify CLI performance meets requirements specified in Section 2.2.9.3.
    
    Tests command initialization time and ensures <2s requirement compliance.
    
    Returns:
        Dict containing performance test results and timing metrics
        
    Raises:
        CLIError: If performance requirements are not met
    """
    if not _CLI_COMPONENTS_AVAILABLE:
        return {
            'passed': False,
            'reason': 'CLI components not available',
            'initialization_time': None
        }
    
    try:
        # Measure CLI initialization time
        start_time = time.time()
        
        # Test basic CLI component loading without full execution
        test_config = get_cli_config()  # Should be fast access
        
        initialization_time = time.time() - start_time
        
        # Check against 2-second requirement from Section 2.2.9.3
        performance_target = 2.0  # seconds
        passed = initialization_time < performance_target
        
        return {
            'passed': passed,
            'initialization_time': initialization_time,
            'target_time': performance_target,
            'margin': performance_target - initialization_time,
            'status': 'PASS' if passed else 'FAIL'
        }
        
    except Exception as e:
        return {
            'passed': False,
            'reason': f'Performance test error: {e}',
            'initialization_time': None
        }


def register_cli_command(name: str, command_func: Callable, **kwargs) -> bool:
    """
    Register additional CLI commands for extensibility and plugin support.
    
    Enables dynamic CLI command registration for research-specific extensions
    and custom workflow integration patterns.
    
    Args:
        name: Command name for CLI invocation
        command_func: Click-decorated command function
        **kwargs: Additional Click command options
        
    Returns:
        bool: True if registration successful, False otherwise
        
    Example:
        >>> @click.command()
        >>> def custom_analysis():
        ...     '''Custom analysis command.'''
        ...     pass
        >>> register_cli_command('analyze', custom_analysis)
        True
    """
    if not _CLI_COMPONENTS_AVAILABLE:
        logging.warning(f"Cannot register command '{name}': CLI components not available")
        return False
    
    try:
        # Add command to the main CLI group for unified access
        if hasattr(cli, 'add_command'):
            cli.add_command(command_func, name=name, **kwargs)
            logging.info(f"Successfully registered CLI command: {name}")
            return True
        else:
            logging.warning(f"CLI group does not support dynamic command registration")
            return False
            
    except Exception as e:
        logging.error(f"Failed to register command '{name}': {e}")
        return False


def get_available_commands() -> List[str]:
    """
    Retrieve list of available CLI commands for discovery and help generation.
    
    Returns:
        List of command names available through the CLI interface
        
    Example:
        >>> from {{cookiecutter.project_slug}}.cli import get_available_commands
        >>> commands = get_available_commands()
        >>> print(f"Available commands: {', '.join(commands)}")
        Available commands: run, config, visualize
    """
    if not _CLI_COMPONENTS_AVAILABLE:
        return []
    
    try:
        # Extract command names from CLI group if available
        if hasattr(cli, 'commands'):
            return list(cli.commands.keys())
        else:
            # Fallback to known commands
            return ['run', 'config', 'visualize']
            
    except Exception as e:
        logging.warning(f"Error retrieving available commands: {e}")
        return []


def validate_cli_installation() -> Dict[str, Any]:
    """
    Comprehensive CLI installation validation and dependency checking.
    
    Verifies all required dependencies are available and CLI system is properly
    configured for operation per Feature F-013 requirements.
    
    Returns:
        Dict containing validation results and diagnostic information
        
    Example:
        >>> from {{cookiecutter.project_slug}}.cli import validate_cli_installation
        >>> result = validate_cli_installation()
        >>> if result['valid']:
        ...     print("CLI installation is valid")
        ... else:
        ...     print(f"Issues found: {result['issues']}")
    """
    validation_result = {
        'valid': False,
        'issues': [],
        'warnings': [],
        'components': {},
        'performance': {},
        'recommendations': []
    }
    
    # Check CLI component availability
    validation_result['components']['cli_available'] = _CLI_COMPONENTS_AVAILABLE
    if not _CLI_COMPONENTS_AVAILABLE:
        validation_result['issues'].extend(_CLI_IMPORT_ERRORS)
        validation_result['recommendations'].append(
            "Install missing dependencies: pip install click hydra-core"
        )
    
    # Check performance compliance
    if _CLI_COMPONENTS_AVAILABLE:
        perf_result = verify_cli_performance()
        validation_result['performance'] = perf_result
        
        if not perf_result['passed']:
            validation_result['warnings'].append(
                f"CLI initialization time may exceed 2s requirement: {perf_result}"
            )
    
    # Check for required system dependencies
    try:
        import click
        validation_result['components']['click'] = click.__version__
    except ImportError:
        validation_result['issues'].append("Click framework not available")
        validation_result['recommendations'].append("Install Click: pip install click")
    
    try:
        import hydra
        validation_result['components']['hydra'] = hydra.__version__
    except ImportError:
        validation_result['issues'].append("Hydra configuration system not available")
        validation_result['recommendations'].append("Install Hydra: pip install hydra-core")
    
    # Determine overall validation status
    validation_result['valid'] = (
        len(validation_result['issues']) == 0 and 
        _CLI_COMPONENTS_AVAILABLE
    )
    
    return validation_result


# Unified namespace exports for CLI package access
__all__ = [
    # Core CLI functions and entry points
    'main',
    'cli',
    'run',
    'config', 
    'visualize',
    
    # Configuration and system management
    'validate_configuration',
    'initialize_system',
    'cleanup_system',
    'get_cli_config',
    'set_cli_config',
    
    # Error handling and exceptions
    'CLIError',
    'handle_cli_exception',
    
    # Package utilities and diagnostics
    'get_cli_status',
    'verify_cli_performance',
    'validate_cli_installation',
    'get_available_commands',
    'register_cli_command',
    
    # Package metadata
    '__version__',
    '__author__',
    '__cli_available__',
    '__import_errors__'
]


# Package-level initialization and startup verification
def _initialize_cli_package():
    """
    Initialize CLI package with performance monitoring and status verification.
    
    This function runs during package import to ensure CLI system readiness
    and compliance with performance requirements.
    """
    if _CLI_COMPONENTS_AVAILABLE:
        # Log successful CLI package initialization
        logging.debug(f"CLI package initialized successfully (version {__version__})")
        
        # Perform startup performance check
        perf_result = verify_cli_performance()
        if not perf_result['passed']:
            logging.warning(
                f"CLI initialization performance warning: {perf_result.get('reason', 'Unknown')}"
            )
    else:
        logging.warning(
            f"CLI package initialized with limited functionality: {_CLI_IMPORT_ERRORS}"
        )


# Execute package initialization
_initialize_cli_package()


# Enable direct script execution support for CLI development and testing
if __name__ == "__main__":
    """
    Support direct execution of CLI package for development and testing.
    
    Usage:
        python -m {{cookiecutter.project_slug}}.cli
        python src/{{cookiecutter.project_slug}}/cli/__init__.py
    """
    if _CLI_COMPONENTS_AVAILABLE:
        print(f"{{cookiecutter.project_slug}} CLI Package v{__version__}")
        print("Available commands:", ", ".join(get_available_commands()))
        print("\nFor help, run: python -m {{cookiecutter.project_slug}}.cli.main --help")
        
        # Show CLI status for diagnostics
        status = get_cli_status()
        print(f"\nCLI Status: {'✓ Available' if status['available'] else '✗ Unavailable'}")
        
        # Optionally run main CLI if arguments provided
        if len(sys.argv) > 1:
            main()
    else:
        print(f"CLI components not available: {_CLI_IMPORT_ERRORS}")
        sys.exit(1)