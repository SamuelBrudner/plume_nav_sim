"""
Main CLI implementation for the odor plume navigation system.

This module provides a comprehensive command-line interface supporting simulation
execution, configuration validation, batch processing, parameter sweeps, and 
visualization export. Built with Click framework integration and Hydra configuration
management for sophisticated experiment orchestration and reproducible research workflows.

Features:
- @hydra.main decorator for seamless configuration injection
- Multi-run parameter sweep support via --multirun flag
- Configuration validation and export capabilities
- Batch processing for automated experiment execution
- Visualization export with MP4 and publication-quality outputs
- Comprehensive error handling and recovery strategies
- Environment variable interpolation and local override management

Usage Examples:
    # Basic simulation execution
    python -m {{cookiecutter.project_slug}}.cli.main run

    # Parameter override examples
    python -m {{cookiecutter.project_slug}}.cli.main run navigator.max_speed=2.0
    python -m {{cookiecutter.project_slug}}.cli.main run video_plume.flip=true
    
    # Multi-run parameter sweeps
    python -m {{cookiecutter.project_slug}}.cli.main --multirun run navigator.max_speed=1.0,2.0,3.0
    
    # Configuration validation and export
    python -m {{cookiecutter.project_slug}}.cli.main config validate
    python -m {{cookiecutter.project_slug}}.cli.main config export --output-file config_dump.yaml
    
    # Batch processing and visualization export
    python -m {{cookiecutter.project_slug}}.cli.main run --batch --export-animation
    python -m {{cookiecutter.project_slug}}.cli.main visualize --input results.npz --format mp4

Author: Generated by Blitzy Template Engine
Version: 2.0.0
"""

import sys
import time
import logging
import traceback
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import click
import hydra
import numpy as np
from omegaconf import DictConfig, OmegaConf
from loguru import logger

# Import core navigation components
try:
    from {{cookiecutter.project_slug}}.api.navigation import create_navigator, create_video_plume, run_plume_simulation
    from {{cookiecutter.project_slug}}.core.navigator import NavigatorProtocol
    from {{cookiecutter.project_slug}}.data.video_plume import VideoPlume
    from {{cookiecutter.project_slug}}.config.schemas import NavigatorConfig, VideoPlumeConfig, SimulationConfig
    from {{cookiecutter.project_slug}}.utils.seed_manager import set_global_seed, get_current_seed
    from {{cookiecutter.project_slug}}.utils.visualization import visualize_simulation_results, export_animation
    from {{cookiecutter.project_slug}}.utils.logging import setup_logging, get_logger
    from {{cookiecutter.project_slug}}.db.session import get_session, close_session
except ImportError as e:
    # Graceful handling of missing dependencies during development
    logger.error(f"Failed to import required components: {e}")
    logger.info("Some CLI commands may not be available. Please ensure all dependencies are installed.")


# Global configuration instance for CLI state management
_cli_config: Optional[DictConfig] = None


def get_cli_config() -> Optional[DictConfig]:
    """Retrieve the global CLI configuration instance."""
    return _cli_config


def set_cli_config(config: DictConfig) -> None:
    """Set the global CLI configuration instance."""
    global _cli_config
    _cli_config = config


class CLIError(Exception):
    """Custom exception for CLI-specific errors with enhanced error context."""
    
    def __init__(self, message: str, exit_code: int = 1, details: Optional[Dict[str, Any]] = None):
        super().__init__(message)
        self.exit_code = exit_code
        self.details = details or {}
        self.timestamp = time.time()


def handle_cli_exception(func):
    """Decorator for comprehensive CLI exception handling and error recovery."""
    def wrapper(*args, **kwargs):
        try:
            start_time = time.time()
            result = func(*args, **kwargs)
            execution_time = time.time() - start_time
            
            logger.success(f"Command '{func.__name__}' completed successfully in {execution_time:.2f}s")
            return result
            
        except CLIError as e:
            logger.error(f"CLI Error: {e}")
            if e.details:
                logger.debug(f"Error details: {e.details}")
            sys.exit(e.exit_code)
            
        except KeyboardInterrupt:
            logger.warning("Operation interrupted by user")
            sys.exit(130)  # Standard exit code for SIGINT
            
        except Exception as e:
            logger.error(f"Unexpected error in '{func.__name__}': {e}")
            logger.debug(f"Traceback: {traceback.format_exc()}")
            sys.exit(1)
    
    return wrapper


def validate_configuration(config: DictConfig) -> bool:
    """
    Comprehensive configuration validation with detailed error reporting.
    
    Args:
        config: Hydra configuration object to validate
        
    Returns:
        bool: True if configuration is valid
        
    Raises:
        CLIError: If configuration validation fails
    """
    validation_errors = []
    
    try:
        # Validate navigator configuration if present
        if 'navigator' in config:
            try:
                NavigatorConfig(**config.navigator)
                logger.debug("Navigator configuration validation passed")
            except Exception as e:
                validation_errors.append(f"Navigator config error: {e}")
        
        # Validate video plume configuration if present
        if 'video_plume' in config:
            try:
                # Check if video file exists if path is specified
                if 'video_path' in config.video_plume and config.video_plume.video_path:
                    video_path = Path(config.video_plume.video_path)
                    if not video_path.exists():
                        validation_errors.append(f"Video file not found: {video_path}")
                
                VideoPlumeConfig(**config.video_plume)
                logger.debug("Video plume configuration validation passed")
            except Exception as e:
                validation_errors.append(f"Video plume config error: {e}")
        
        # Validate simulation configuration if present
        if 'simulation' in config:
            try:
                SimulationConfig(**config.simulation)
                logger.debug("Simulation configuration validation passed")
            except Exception as e:
                validation_errors.append(f"Simulation config error: {e}")
        
        # Check for required paths and directories
        if 'environment' in config and 'paths' in config.environment:
            paths = config.environment.paths
            for path_key, path_value in paths.items():
                if path_value and not Path(path_value).parent.exists():
                    logger.warning(f"Parent directory for {path_key} does not exist: {Path(path_value).parent}")
        
        if validation_errors:
            error_details = {
                "validation_errors": validation_errors,
                "config_keys": list(config.keys())
            }
            raise CLIError(
                f"Configuration validation failed with {len(validation_errors)} errors",
                exit_code=2,
                details=error_details
            )
        
        logger.info("Configuration validation completed successfully")
        return True
        
    except Exception as e:
        if isinstance(e, CLIError):
            raise
        raise CLIError(f"Configuration validation error: {e}", exit_code=2)


def initialize_system(config: DictConfig) -> Dict[str, Any]:
    """
    Initialize system components with comprehensive setup and validation.
    
    Args:
        config: Hydra configuration object
        
    Returns:
        Dict containing initialized system components
        
    Raises:
        CLIError: If system initialization fails
    """
    try:
        logger.info("Initializing odor plume navigation system...")
        
        # Set up logging configuration
        setup_logging(config.get('logging', {}))
        
        # Initialize random seed management for reproducibility
        if 'reproducibility' in config and config.reproducibility.get('global_seed') is not None:
            seed = config.reproducibility.global_seed
            set_global_seed(seed)
            logger.info(f"Global random seed set to: {seed}")
        elif config.get('reproducibility', {}).get('auto_seed', True):
            seed = set_global_seed()
            logger.info(f"Auto-generated random seed: {seed}")
        
        # Initialize database session if enabled
        session = None
        if config.get('database', {}).get('enabled', False):
            try:
                session = get_session(config.database)
                logger.info("Database session initialized successfully")
            except Exception as e:
                logger.warning(f"Database initialization failed: {e}")
        
        # Validate system performance settings
        performance_config = config.get('performance', {})
        if performance_config.get('numpy', {}).get('thread_count', 0) > 0:
            import os
            os.environ['OMP_NUM_THREADS'] = str(performance_config.numpy.thread_count)
            logger.debug(f"NumPy thread count set to: {performance_config.numpy.thread_count}")
        
        system_info = {
            'config': config,
            'session': session,
            'seed': get_current_seed() if 'reproducibility' in config else None,
            'initialized_at': time.time()
        }
        
        logger.success("System initialization completed successfully")
        return system_info
        
    except Exception as e:
        raise CLIError(f"System initialization failed: {e}", exit_code=3)


def cleanup_system(system_info: Dict[str, Any]) -> None:
    """
    Clean up system resources and close connections.
    
    Args:
        system_info: Dictionary containing system components to clean up
    """
    try:
        logger.info("Cleaning up system resources...")
        
        # Close database session if exists
        if system_info.get('session'):
            close_session(system_info['session'])
            logger.debug("Database session closed")
        
        # Log execution summary
        if 'initialized_at' in system_info:
            total_time = time.time() - system_info['initialized_at']
            logger.info(f"Total execution time: {total_time:.2f}s")
        
        logger.success("System cleanup completed")
        
    except Exception as e:
        logger.warning(f"Error during system cleanup: {e}")


# Click command group with context settings for proper error handling
@click.group(context_settings={'help_option_names': ['-h', '--help']})
@click.option('--verbose', '-v', is_flag=True, help='Enable verbose output and detailed logging')
@click.option('--quiet', '-q', is_flag=True, help='Suppress non-error output')
@click.option('--config-dir', type=click.Path(exists=True), help='Override default configuration directory')
@click.pass_context
def cli(ctx: click.Context, verbose: bool, quiet: bool, config_dir: Optional[str]) -> None:
    """
    Odor Plume Navigation System - Comprehensive CLI for simulation and analysis.
    
    This command-line interface provides access to all odor plume navigation
    system capabilities including simulation execution, configuration management,
    visualization export, and batch processing workflows.
    
    Configuration is managed through Hydra with support for hierarchical
    composition, environment variable interpolation, and parameter overrides.
    
    Examples:
        # Basic simulation with default configuration
        {{cookiecutter.project_slug}} run
        
        # Parameter override examples
        {{cookiecutter.project_slug}} run navigator.max_speed=2.0 simulation.fps=60
        
        # Multi-run parameter sweeps
        {{cookiecutter.project_slug}} --multirun run navigator.max_speed=1,2,3
        
        # Configuration validation and debugging
        {{cookiecutter.project_slug}} config validate --verbose
        {{cookiecutter.project_slug}} config export --format yaml
    
    For detailed help on any command, use: {{cookiecutter.project_slug}} COMMAND --help
    """
    # Ensure context object exists for passing state between commands
    ctx.ensure_object(dict)
    
    # Set global verbosity and logging preferences
    ctx.obj['verbose'] = verbose
    ctx.obj['quiet'] = quiet
    ctx.obj['config_dir'] = config_dir
    
    # Configure loguru based on verbosity settings
    if quiet:
        logger.configure(handlers=[{"sink": sys.stderr, "level": "ERROR"}])
    elif verbose:
        logger.configure(handlers=[{"sink": sys.stderr, "level": "DEBUG", "format": 
            "<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | "
            "<cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> | <level>{message}</level>"}])
    else:
        logger.configure(handlers=[{"sink": sys.stderr, "level": "INFO"}])


@cli.command()
@click.option('--dry-run', is_flag=True, help='Validate configuration and setup without running simulation')
@click.option('--batch', is_flag=True, help='Enable headless batch processing mode')
@click.option('--export-animation', is_flag=True, help='Export animation as MP4 video file')
@click.option('--export-trajectory', is_flag=True, help='Export trajectory plots as high-quality images')
@click.option('--output-dir', type=click.Path(), help='Override output directory for results')
@click.option('--max-duration', type=float, help='Maximum simulation duration in seconds')
@click.option('--num-agents', type=int, help='Number of agents for multi-agent simulation')
@click.pass_context
@handle_cli_exception
def run(ctx: click.Context, dry_run: bool, batch: bool, export_animation: bool, 
        export_trajectory: bool, output_dir: Optional[str], max_duration: Optional[float],
        num_agents: Optional[int]) -> None:
    """
    Execute odor plume navigation simulation with comprehensive configuration support.
    
    This command runs complete simulations using the Hydra configuration system
    with support for parameter overrides, multi-agent scenarios, and automated
    data export. Results are automatically organized in timestamped directories
    for experiment tracking and reproducibility.
    
    Performance Requirements:
        - Command initialization: <2s per Section 2.2.9.3
        - Real-time simulation: 30+ FPS for interactive scenarios
        - Memory usage: <100MB CLI overhead per requirements
    
    Examples:
        # Basic simulation execution
        {{cookiecutter.project_slug}} run
        
        # Override configuration parameters
        {{cookiecutter.project_slug}} run navigator.max_speed=3.0 simulation.fps=60
        
        # Multi-agent simulation with export
        {{cookiecutter.project_slug}} run --num-agents 5 --export-animation
        
        # Batch processing mode for automated execution
        {{cookiecutter.project_slug}} run --batch --output-dir /data/experiments
        
        # Dry run for configuration validation
        {{cookiecutter.project_slug}} run --dry-run --verbose
    """
    config = get_cli_config()
    if config is None:
        raise CLIError("Configuration not available. Ensure Hydra initialization is complete.", exit_code=4)
    
    logger.info("Starting simulation execution command")
    
    # Apply CLI parameter overrides to configuration
    if max_duration is not None:
        OmegaConf.set(config, 'simulation.max_duration', max_duration)
    
    if num_agents is not None:
        OmegaConf.set(config, 'navigator.num_agents', num_agents)
    
    if output_dir is not None:
        OmegaConf.set(config, 'hydra.run.dir', output_dir)
    
    # Configure batch processing mode
    if batch:
        OmegaConf.set(config, 'visualization.animation.enabled', False)
        OmegaConf.set(config, 'environment.debug_mode', False)
        logger.info("Batch processing mode enabled - headless execution")
    
    # Validate configuration before proceeding
    validate_configuration(config)
    
    # Initialize system components
    system_info = initialize_system(config)
    
    try:
        if dry_run:
            logger.info("Dry run mode - validating setup without execution")
            
            # Test component creation without running simulation
            try:
                navigator = create_navigator(config.navigator)
                logger.success(f"Navigator validation passed: {type(navigator).__name__}")
                
                if 'video_plume' in config and config.video_plume.get('video_path'):
                    video_plume = create_video_plume(config.video_plume)
                    logger.success(f"Video plume validation passed: {video_plume.frame_count} frames")
                else:
                    logger.info("Video plume configuration not provided - skipping validation")
                
                logger.success("Dry run validation completed successfully")
                return
                
            except Exception as e:
                raise CLIError(f"Dry run validation failed: {e}", exit_code=5)
        
        # Execute actual simulation
        logger.info("Initializing simulation components...")
        
        # Create navigator instance
        navigator = create_navigator(config.navigator)
        logger.info(f"Navigator created: {navigator.num_agents} agent(s)")
        
        # Create video plume environment
        if 'video_plume' not in config or not config.video_plume.get('video_path'):
            raise CLIError("Video plume configuration missing. Please specify video_plume.video_path", exit_code=6)
        
        video_plume = create_video_plume(config.video_plume)
        logger.info(f"Video plume loaded: {video_plume.frame_count} frames, {video_plume.width}x{video_plume.height}")
        
        # Execute simulation with progress tracking
        simulation_config = config.get('simulation', {})
        logger.info("Starting simulation execution...")
        
        start_time = time.time()
        positions, orientations, readings = run_plume_simulation(
            navigator=navigator,
            video_plume=video_plume,
            **simulation_config
        )
        execution_time = time.time() - start_time
        
        logger.success(f"Simulation completed in {execution_time:.2f}s")
        logger.info(f"Trajectory data shape: {positions.shape}")
        
        # Export results if requested
        output_files = []
        
        # Save raw simulation data
        output_path = Path(config.hydra.run.dir if hasattr(config.hydra, 'run') else "outputs")
        output_path.mkdir(parents=True, exist_ok=True)
        
        data_file = output_path / "simulation_results.npz"
        np.savez_compressed(data_file, 
                          positions=positions, 
                          orientations=orientations, 
                          readings=readings,
                          config=OmegaConf.to_yaml(config))
        output_files.append(data_file)
        logger.info(f"Simulation data saved: {data_file}")
        
        # Generate visualizations if requested
        if export_trajectory or not batch:
            try:
                viz_config = config.get('visualization', {})
                figure = visualize_simulation_results(
                    positions=positions,
                    orientations=orientations,
                    **viz_config.get('plotting', {})
                )
                
                if export_trajectory:
                    trajectory_file = output_path / "trajectory_plot.png"
                    figure.savefig(trajectory_file, dpi=300, bbox_inches='tight')
                    output_files.append(trajectory_file)
                    logger.info(f"Trajectory plot saved: {trajectory_file}")
                
            except Exception as e:
                logger.warning(f"Visualization generation failed: {e}")
        
        # Export animation if requested
        if export_animation:
            try:
                animation_file = output_path / "simulation_animation.mp4"
                export_animation(
                    positions=positions,
                    orientations=orientations,
                    video_plume=video_plume,
                    output_path=animation_file,
                    **config.get('visualization', {}).get('animation', {})
                )
                output_files.append(animation_file)
                logger.info(f"Animation exported: {animation_file}")
                
            except Exception as e:
                logger.warning(f"Animation export failed: {e}")
        
        # Log summary
        logger.success(f"Simulation completed successfully")
        logger.info(f"Output files generated: {len(output_files)}")
        for file_path in output_files:
            logger.info(f"  - {file_path}")
    
    finally:
        cleanup_system(system_info)


@cli.group()
@click.pass_context
def config(ctx: click.Context) -> None:
    """
    Configuration management and validation commands.
    
    This command group provides comprehensive configuration management
    capabilities including validation, export, and debugging tools for
    the Hydra-based configuration system.
    
    Examples:
        # Validate current configuration
        {{cookiecutter.project_slug}} config validate
        
        # Export configuration with overrides
        {{cookiecutter.project_slug}} config export --format yaml
        
        # Validate with specific overrides
        {{cookiecutter.project_slug}} config validate navigator.max_speed=5.0
    """
    pass


@config.command()
@click.option('--format', 'output_format', type=click.Choice(['yaml', 'json', 'pretty']), 
              default='pretty', help='Output format for validation results')
@click.option('--strict', is_flag=True, help='Enable strict validation with enhanced error checking')
@click.pass_context
@handle_cli_exception
def validate(ctx: click.Context, output_format: str, strict: bool) -> None:
    """
    Validate configuration files and parameter settings.
    
    Performs comprehensive validation of all configuration components
    including Pydantic schema validation, file existence checks, and
    parameter constraint verification.
    
    Examples:
        # Basic validation
        {{cookiecutter.project_slug}} config validate
        
        # Strict validation with detailed output
        {{cookiecutter.project_slug}} config validate --strict --format yaml
        
        # Validate with parameter overrides
        {{cookiecutter.project_slug}} config validate navigator.max_speed=10.0
    """
    config = get_cli_config()
    if config is None:
        raise CLIError("Configuration not available for validation", exit_code=4)
    
    logger.info("Starting configuration validation...")
    
    try:
        # Perform validation with enhanced checking if strict mode
        is_valid = validate_configuration(config)
        
        if strict:
            # Additional strict validation checks
            validation_results = {}
            
            # Check for unused configuration keys
            used_keys = set()
            for section in ['navigator', 'video_plume', 'simulation', 'visualization']:
                if section in config:
                    used_keys.update(config[section].keys())
            
            # Validate numeric ranges and constraints
            if 'navigator' in config:
                nav_config = config.navigator
                if nav_config.get('max_speed', 0) > 100:
                    logger.warning("Navigator max_speed exceeds recommended maximum (100)")
                if nav_config.get('num_agents', 1) > 1000:
                    logger.warning("Number of agents exceeds system limits (1000)")
            
            validation_results['strict_checks'] = True
            validation_results['timestamp'] = time.time()
        
        # Output validation results in requested format
        if output_format == 'yaml':
            validation_output = OmegaConf.to_yaml(config)
            click.echo("Configuration (YAML format):")
            click.echo(validation_output)
        elif output_format == 'json':
            validation_output = OmegaConf.to_yaml(config)
            click.echo("Configuration (JSON format):")
            click.echo(validation_output)
        else:  # pretty format
            click.echo("âœ… Configuration validation passed successfully")
            click.echo(f"ðŸ“Š Configuration sections: {list(config.keys())}")
            if 'navigator' in config:
                click.echo(f"ðŸŽ¯ Navigator: {config.navigator.get('num_agents', 1)} agent(s)")
            if 'video_plume' in config and config.video_plume.get('video_path'):
                click.echo(f"ðŸŽ¬ Video: {config.video_plume.video_path}")
        
        logger.success("Configuration validation completed successfully")
        
    except Exception as e:
        raise CLIError(f"Configuration validation failed: {e}", exit_code=7)


@config.command()
@click.option('--output-file', '-o', type=click.Path(), help='Output file for exported configuration')
@click.option('--format', 'output_format', type=click.Choice(['yaml', 'json']), 
              default='yaml', help='Export format')
@click.option('--include-defaults', is_flag=True, help='Include default values in export')
@click.option('--resolved', is_flag=True, help='Export with resolved interpolations')
@click.pass_context
@handle_cli_exception
def export(ctx: click.Context, output_file: Optional[str], output_format: str, 
           include_defaults: bool, resolved: bool) -> None:
    """
    Export current configuration with all overrides and interpolations.
    
    Generates a complete configuration export including parameter overrides,
    environment variable interpolations, and system defaults for documentation
    and reproducibility purposes.
    
    Examples:
        # Export to YAML file
        {{cookiecutter.project_slug}} config export -o config.yaml
        
        # Export with resolved environment variables
        {{cookiecutter.project_slug}} config export --resolved --format json
        
        # Export including all defaults
        {{cookiecutter.project_slug}} config export --include-defaults
    """
    config = get_cli_config()
    if config is None:
        raise CLIError("Configuration not available for export", exit_code=4)
    
    logger.info("Exporting configuration...")
    
    try:
        # Prepare configuration for export
        export_config = config
        
        if resolved:
            # Resolve all interpolations and environment variables
            export_config = OmegaConf.to_container(config, resolve=True)
            export_config = OmegaConf.create(export_config)
        
        # Generate export content
        if output_format == 'json':
            import json
            export_content = json.dumps(OmegaConf.to_container(export_config), indent=2)
        else:  # yaml
            export_content = OmegaConf.to_yaml(export_config)
        
        # Add export metadata
        metadata = f"""# Configuration Export
# Generated by: {{cookiecutter.project_slug}} CLI
# Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}
# Format: {output_format}
# Resolved: {resolved}
# Include Defaults: {include_defaults}

"""
        
        if output_format == 'yaml':
            export_content = metadata + export_content
        
        # Output to file or console
        if output_file:
            output_path = Path(output_file)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            output_path.write_text(export_content)
            logger.success(f"Configuration exported to: {output_path}")
        else:
            click.echo(export_content)
        
    except Exception as e:
        raise CLIError(f"Configuration export failed: {e}", exit_code=8)


@cli.command()
@click.option('--input-file', '-i', type=click.Path(exists=True), required=True, 
              help='Input simulation results file (.npz format)')
@click.option('--format', 'output_format', type=click.Choice(['mp4', 'gif', 'png', 'pdf']), 
              default='mp4', help='Output format for visualization')
@click.option('--output-file', '-o', type=click.Path(), help='Output file path')
@click.option('--quality', type=click.Choice(['low', 'medium', 'high', 'publication']), 
              default='high', help='Output quality setting')
@click.option('--show-trails', is_flag=True, help='Show agent trajectory trails')
@click.option('--fps', type=int, default=30, help='Frame rate for video output')
@click.pass_context
@handle_cli_exception
def visualize(ctx: click.Context, input_file: str, output_format: str, output_file: Optional[str],
              quality: str, show_trails: bool, fps: int) -> None:
    """
    Generate visualizations from simulation results.
    
    Creates high-quality visualizations including animations, trajectory plots,
    and publication-ready figures from saved simulation data. Supports multiple
    output formats with configurable quality settings.
    
    Examples:
        # Create MP4 animation from results
        {{cookiecutter.project_slug}} visualize -i results.npz --format mp4
        
        # Generate publication-quality trajectory plot
        {{cookiecutter.project_slug}} visualize -i results.npz --format pdf --quality publication
        
        # Custom animation with trails
        {{cookiecutter.project_slug}} visualize -i results.npz --show-trails --fps 60
    """
    logger.info(f"Loading simulation results from: {input_file}")
    
    try:
        # Load simulation data
        data = np.load(input_file)
        positions = data['positions']
        orientations = data['orientations']
        
        # Extract configuration if available
        config_yaml = data.get('config', b'').item() if 'config' in data else None
        viz_config = {}
        if config_yaml:
            try:
                full_config = OmegaConf.create(yaml.safe_load(config_yaml))
                viz_config = full_config.get('visualization', {})
            except:
                logger.warning("Could not parse configuration from results file")
        
        logger.info(f"Loaded trajectory data: {positions.shape}")
        
        # Configure visualization parameters
        viz_params = {
            'show_trails': show_trails,
            'quality': quality,
            'fps': fps if output_format in ['mp4', 'gif'] else None
        }
        
        # Generate output filename if not provided
        if not output_file:
            input_path = Path(input_file)
            output_file = input_path.parent / f"{input_path.stem}_visualization.{output_format}"
        
        output_path = Path(output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Generate visualization based on format
        if output_format in ['mp4', 'gif']:
            # Animation export
            logger.info(f"Generating {output_format.upper()} animation...")
            export_animation(
                positions=positions,
                orientations=orientations,
                output_path=output_path,
                **viz_params
            )
        else:
            # Static plot export
            logger.info(f"Generating {output_format.upper()} plot...")
            figure = visualize_simulation_results(
                positions=positions,
                orientations=orientations,
                **viz_params
            )
            
            # Set DPI based on quality
            dpi_settings = {
                'low': 72,
                'medium': 150,
                'high': 300,
                'publication': 600
            }
            
            figure.savefig(output_path, 
                         format=output_format, 
                         dpi=dpi_settings[quality],
                         bbox_inches='tight')
        
        logger.success(f"Visualization saved: {output_path}")
        
    except Exception as e:
        raise CLIError(f"Visualization generation failed: {e}", exit_code=9)


@hydra.main(config_path="../../../conf", config_name="config", version_base=None)
def main(cfg: DictConfig) -> None:
    """
    Main CLI entrypoint with Hydra configuration management.
    
    This function serves as the primary entry point for the CLI application,
    integrating Hydra's configuration management system with Click's command
    framework. It handles global configuration setup, parameter validation,
    and command dispatch.
    
    The @hydra.main decorator enables:
    - Automatic configuration loading from conf/ directory
    - Parameter override support via command-line syntax
    - Multi-run execution with --multirun flag
    - Working directory management for experiment organization
    - Environment variable interpolation and local overrides
    
    Args:
        cfg: Hydra DictConfig object containing complete configuration hierarchy
        
    Environment Variables:
        MATPLOTLIB_BACKEND: Override matplotlib backend (default: Agg for headless)
        DEBUG: Enable debug mode (true/false)
        LOG_LEVEL: Set logging level (DEBUG, INFO, WARNING, ERROR)
        
    Exit Codes:
        0: Success
        1: General error
        2: Configuration validation error
        3: System initialization error
        4: Configuration not available
        5: Dry run validation failed
        6: Missing required configuration
        7: Configuration validation failed
        8: Configuration export failed
        9: Visualization generation failed
        130: Interrupted by user (SIGINT)
    """
    try:
        # Store configuration for CLI commands
        set_cli_config(cfg)
        
        # Log startup information
        logger.info("ðŸš€ Odor Plume Navigation CLI v2.0.0")
        logger.debug(f"Configuration keys: {list(cfg.keys())}")
        logger.debug(f"Working directory: {Path.cwd()}")
        
        # Validate configuration initialization timing (must be <2s per requirements)
        start_time = time.time()
        
        # Perform basic configuration validation
        if not cfg:
            raise CLIError("Empty configuration received from Hydra", exit_code=4)
        
        initialization_time = time.time() - start_time
        if initialization_time > 2.0:
            logger.warning(f"Configuration initialization took {initialization_time:.2f}s (>2s requirement)")
        else:
            logger.debug(f"Configuration initialized in {initialization_time:.3f}s")
        
        # Execute CLI command
        cli()
        
    except SystemExit:
        # Handle normal Click command completion
        pass
    except Exception as e:
        logger.error(f"Fatal error in CLI main: {e}")
        logger.debug(f"Traceback: {traceback.format_exc()}")
        sys.exit(1)


if __name__ == "__main__":
    # Enable direct execution of the CLI module
    main()